/**
* Kms Backend
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* The version of the OpenAPI document: 1.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package com.kms.common.storage


import cn.leancloud.AVException
import cn.leancloud.AVFile
import cn.leancloud.AVUser
import cn.leancloud.AVObject
import cn.leancloud.AVQuery
import cn.leancloud.EngineHook
import cn.leancloud.EngineHookType
import cn.leancloud.annotation.AVClassName
import cn.leancloud.utils.StringUtil

@AVClassName("Post")
class Post : AVObject() {
    companion object {
        const val CLASS = "Post"
        const val KEY_AUTHOR = "author"
        const val KEY_TITLE = "title"
        const val KEY_CONTENT = "content"
        const val KEY_ROOT_POST = "rootPost"
        const val KEY_PARENT_POST = "parentPost"
        const val KEY_COUNT_THUMBUP = "countThumbup"
        const val KEY_COUNT_COMMENT = "countComment"
        const val KEY_COUNT_REPOST = "countRepost"
        const val KEY_REPLIED_AT = "repliedAt"
        const val KEY_DEVELOPMENT = "development"

        fun AVQuery<Post>.whereAuthorIs(author: AVUser): AVQuery<Post> {
            return whereEqualTo(KEY_AUTHOR, author)
        }

        fun AVQuery<Post>.whereRootPostIs(rootPost: Post?): AVQuery<Post> {
            return whereEqualTo(KEY_ROOT_POST, rootPost)
        }

        fun AVQuery<Post>.whereParentPostIs(parentPost: Post?): AVQuery<Post> {
            return whereEqualTo(KEY_PARENT_POST, parentPost)
        }

        /**
         * Create pointer with objectId only for query.
         */
        fun newPointer(objectId: String): Post {
            return createWithoutData(Post::class.java, objectId)
        }

        fun newBuilder(): Builder {
            return Builder()
        }

        @Throws(IllegalArgumentException::class)
        fun validate(x: Post): Post {
            x.title.let {
              // Validation logic.
              require(it.length >= 1) {
                  "title length needs to be at least 1, got ${it.length}"
              }
              require(it.length <= 30) {
                  "title length needs to be at most 30, got ${it.length}"
              }
            }
            x.content.let {
              // Validation logic.
              require(it.length >= 0) {
                  "content length needs to be at least 0, got ${it.length}"
              }
              require(it.length <= 300) {
                  "content length needs to be at most 300, got ${it.length}"
              }
            }
            x.countThumbup?.let {
              // Validation logic.
              require(it >= 0) {
                  "countThumbup needs to be at least 0, got $it"
              }
            }
            x.countComment?.let {
              // Validation logic.
              require(it >= 0) {
                  "countComment needs to be at least 0, got $it"
              }
            }
            x.countRepost?.let {
              // Validation logic.
              require(it >= 0) {
                  "countRepost needs to be at least 0, got $it"
              }
            }
            return x
        }
    }











    /**
     * Author of the post.
     */
    var author: AVUser
        get() {
            val value = get(KEY_AUTHOR)
            return if (value is AVUser) {
                value
            } else {
                throw AVException(AVException.INCORRECT_TYPE, "Invalid value, expect AVUser, got ${value.javaClass}")
            }
        }
        set(value) = put(KEY_AUTHOR, value)

    /**
     * Required, title of the post.
     */
    var title: kotlin.String
        get() {
            val value = get(KEY_TITLE)
            return if (value is kotlin.String) {
                value
            } else {
                throw AVException(AVException.INCORRECT_TYPE, "Invalid value, expect kotlin.String, got ${value.javaClass}")
            }
        }
        set(value) = put(KEY_TITLE, value)

    /**
     * Content of the post.
     */
    var content: kotlin.String
        get() {
            val value = get(KEY_CONTENT)
            return if (value is kotlin.String) {
                value
            } else {
                throw AVException(AVException.INCORRECT_TYPE, "Invalid value, expect kotlin.String, got ${value.javaClass}")
            }
        }
        set(value) = put(KEY_CONTENT, value)

    /**
     * Root post if this post is a re-post, otherwise set to `null`
     */
    var rootPost: Post?
        get() {
            val value = get(KEY_ROOT_POST)
            return if (value is Post?) {
                value
            } else {
                getJSONObject(KEY_ROOT_POST)
                    .getString(KEY_OBJECT_ID)?.let {
                        createWithoutData(Post::class.java, it)
                    }
            }
        }
        set(value) = put(KEY_ROOT_POST, value)

    /**
     * Parent post if this post is a re-post, otherwise set to `null`
     */
    var parentPost: Post?
        get() {
            val value = get(KEY_PARENT_POST)
            return if (value is Post?) {
                value
            } else {
                getJSONObject(KEY_PARENT_POST)
                    .getString(KEY_OBJECT_ID)?.let {
                        createWithoutData(Post::class.java, it)
                    }
            }
        }
        set(value) = put(KEY_PARENT_POST, value)

    /**
     * count number of thumbup in PostReaction.
     */
    var countThumbup: kotlin.Int?
        get() {
            val value = get(KEY_COUNT_THUMBUP)
            return if (value is kotlin.Int?) {
                value
            } else {
                throw AVException(AVException.INCORRECT_TYPE, "Invalid value, expect kotlin.Int?, got ${value.javaClass}")
            }
        }
        set(value) = put(KEY_COUNT_THUMBUP, value)

    var countComment: kotlin.Int?
        get() {
            val value = get(KEY_COUNT_COMMENT)
            return if (value is kotlin.Int?) {
                value
            } else {
                throw AVException(AVException.INCORRECT_TYPE, "Invalid value, expect kotlin.Int?, got ${value.javaClass}")
            }
        }
        set(value) = put(KEY_COUNT_COMMENT, value)

    var countRepost: kotlin.Int?
        get() {
            val value = get(KEY_COUNT_REPOST)
            return if (value is kotlin.Int?) {
                value
            } else {
                throw AVException(AVException.INCORRECT_TYPE, "Invalid value, expect kotlin.Int?, got ${value.javaClass}")
            }
        }
        set(value) = put(KEY_COUNT_REPOST, value)

    /**
     * Latest replied time (include comment and re-post)
     */
    var repliedAt: java.util.Date?
        get() = getDate(KEY_REPLIED_AT)
        set(value) = put(KEY_REPLIED_AT, StringUtil.stringFromDate(value))

    /**
     * Differentiate the posts version, true is beta.
     */
    var development: kotlin.Boolean?
        get() {
            val value = get(KEY_DEVELOPMENT)
            return if (value is kotlin.Boolean?) {
                value
            } else {
                throw AVException(AVException.INCORRECT_TYPE, "Invalid value, expect kotlin.Boolean?, got ${value.javaClass}")
            }
        }
        set(value) = put(KEY_DEVELOPMENT, value)


    class Builder internal constructor() {
        val value: Post = Post()

        fun build(): Post {
            return Post.validate(value)
        }

        fun setAuthor(author: AVUser): Builder {
            value.author = author
            return this
        }

        fun setTitle(title: kotlin.String): Builder {
            value.title = title
            return this
        }

        fun setContent(content: kotlin.String): Builder {
            value.content = content
            return this
        }

        fun setRootPost(rootPost: Post?): Builder {
            value.rootPost = rootPost
            return this
        }

        fun setParentPost(parentPost: Post?): Builder {
            value.parentPost = parentPost
            return this
        }

        fun setCountThumbup(countThumbup: kotlin.Int?): Builder {
            value.countThumbup = countThumbup
            return this
        }

        fun setCountComment(countComment: kotlin.Int?): Builder {
            value.countComment = countComment
            return this
        }

        fun setCountRepost(countRepost: kotlin.Int?): Builder {
            value.countRepost = countRepost
            return this
        }

        fun setRepliedAt(repliedAt: java.util.Date?): Builder {
            value.repliedAt = repliedAt
            return this
        }

        fun setDevelopment(development: kotlin.Boolean?): Builder {
            value.development = development
            return this
        }
    }
}

open class PostHook {
    open fun onBeforeSave(x: Post): Post {
        return Post.validate(x)
    }
    open fun onBeforeUpdate(x: Post): Post {
        return Post.validate(x)
    }
    open fun onBeforeDelete(x: Post): Post {
        return Post.validate(x)
    }
    open fun onAfterSave(x: Post) {
    }
}

object PostHookFunction {
    var hook = PostHook()

    @JvmStatic
    @EngineHook(className = Post.CLASS, type = EngineHookType.beforeSave)
    fun onBeforeSave(x: Post): Post {
        return hook.onBeforeSave(x)
    }

    @JvmStatic
    @EngineHook(className = Post.CLASS, type = EngineHookType.beforeUpdate)
    fun onBeforeUpdate(x: Post): Post {
        return hook.onBeforeUpdate(x)
    }

    @JvmStatic
    @EngineHook(className = Post.CLASS, type = EngineHookType.beforeDelete)
    fun onBeforeDelete(x: Post): Post {
        return hook.onBeforeDelete(x)
    }

    @JvmStatic
    @EngineHook(className = Post.CLASS, type = EngineHookType.afterSave)
    fun onAfterSave(x: Post) {
        return hook.onAfterSave(x)
    }
}
